<html><head>
<title>MoonMon: Small Beginnings</title>
</head>
<body>
  <style>
body {
  font-family: Verdana, sans-serif;
  background-color:#1a1b1c;
  color:aquamarine;
  a:link{ color:aquamarine;}
  a:visited{ color:teal;}
  a:hover{ color:wheat;}
  a:active{ color:whitesmoke;}
}
</style>
<!-- Header -->
<div style="background-color:#1a1b1c;margin-left:20%;display:flex;justify-content: space-around;align-items: center;position:sticky;top:0;opacity:1;z-index: 3;">
<div style="text-align: left;margin-right:20%;"><a href="00.html">&lt;</a></div>
<div style="text-align: center;margin-right:20%;"><a href="index.html">~</a></div>
<div style="text-align: right;margin-right:20%;"><a href="02.html">&gt;</a></div>
</div>

<!-- Body -->
<hr style="color:wheat;">
<div style="margin-left:20%;margin-right:20%;overflow-wrap:break-word;">
  <h2>MoonMon: Small Beginnings</h2>
<p>I recently made public a project I've been working on for a few months now, called <a href="https://github.com/ag-michael/MoonMon/" target="_blank">MoonMon</a>. 
    In this post—which I hope will become a series—I'm going to detail why I started this project, my plans for it, and what I've learned so far.</p>

<h3>Why I Started Working on MoonMon</h3>

<p>I've had a strong interest in exploit development and vulnerability research for a long time. Last year, I was able to take on the <a href="https://www.offsec.com/courses/exp-301/" target="_blank">Windows User Mode Exploit Development (WUMED)</a> course and subsequently pass the OSED exam.</p>
<p>After the exhausting ordeal that was the OSED exam, I wanted a change of scenery, so to speak. I looked into heap exploitation, exploit development on non-Windows platforms, and kernel-mode exploit development.</p> 

<p>Around this time, I developed a strong interest in EDR evasion and bypasses. I've done some real-world red teaming, which has helped me keep up the skills I learned from the OSCP training I took a few years ago. </p>
<p>As part of that, I had to evade security tools. A handful of times, I've run into scenarios that required evading an EDR or an AV, and often I was able to get past the obstacle after much lab-testing and PoC'ing my payloads. But a few times, I relied on the research and experience other Red Teamers shared with me.</p><p>Sometimes it was a simple trick; other times, hand-crafted and tailored payloads—dark magic, at least to my novice eyes! </p>

<p>Earlier this year, I bought a copy of Matt Hand's excellent book, "<a href="https://nostarch.com/evading-edr" target="_blank">
Evading EDR: The Definitive Guide to Defeating Endpoint Detection Systems,</a>" and gave it a read. It was a true eye-opener. I highly recommend this book for anyone practicing red teaming in a Windows environment. I'd worked with Sysmon for a couple of years, and reading this book was like looking under the hood and seeing how the darn thing worked.</p>
<p>Callbacks, mini-filters, ETW telemetry, AMSI scanning, and more. Matt expands on how sensors collect telemetry, how the EDR architecture functions, and what weaknesses to look for. I wanted a deeper understanding of kernel programming at this point, so I took on Pavel Yosifovich's "<a href="https://www.amazon.com/Windows-Kernel-Programming-Pavel-Yosifovich/dp/B0BW2X91L2" target="_blank">Windows Kernel Programming</a>" book, which, in my opinion, is a decent complement to "Evading EDR".</p>
Pavel's book focuses more on how to write a software-only driver (like Sysmon or EDR drivers), offering plenty of in-depth code examples, tips, and tricks. I hope I can write a more in-depth review of both books when time permits.</p>

<p> Great as these books are, I feared I would end up forgetting most of what I'd learned. This was also around the time when I started reading blog posts and papers on kernel-mode exploitation.</p>

<p>A steep learning curve without a doubt. But fortunately, the folks at Hacksys put together <a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver" target="_blank">HEVD</a>. HEVD is a driver that comes with intentionally crafted vulnerabilities a student of exploit development can use to learn and practice kernel-mode exploitation.</p> 
<p>I felt a bit intimidated at tackling HEVD without having some kernel-mode programming experience. I highly valued all the time I'd spent in windbg and IDA as part of the WUMED course. Driver writing would also help me retain all of that debugger muscle memory and instincts that can only be learned after lots and lots of debugging sessions, bug-checks (BSODs for the uninitiated), and figuring out undocumented side effects.
</p>

<p>I also wanted to hone my C development skills. On top of that, I'd gotten a bit weary of certification exams and courses, and I wanted to spend some time exploring different attack techniques, working on interesting projects, and publishing my work someday.</p>
<p>All this to say that MoonMon was born out of an intersection of multiple needs I had:</p>
<ul>
<li>Learning kernel-mode programming prior to kernel-mode exploitation.</li>
<li>Learning in practice how EDRs work.</li>
<li>Having fun writing an interesting project in C.</li>
<li>Solving problems and exploring ideas I had about how EDRs can do things differently.</li>

</ul>

<p>On that last item, I've complained much over the years as an incident responder and detection engineer about why some of the endpoint security tools I'd used couldn't do things a specific way. Why aren't more details and settings exposed to me as the person who reviews the logs or configures the security tool? Why can't I do AppArmor or SELinux style restrictions on Windows without paying for a commercial EDR?</p>

<p>Why can't I tune the logging, performance, caching behavior, network utilization, and more to fit my needs? I knew that there were good reasons for some of these questions I had, but without actually seeing under the hood how these tools worked, it is hard to determine if these mind-itches I needed to scratch were legitimate missing features or a result of some underlying 
complexity or limitation I didn't know about.</p>
<p>Needless to say, MoonMon was almost a necessity for where I was in my hacker journey.
</p>
<br><br>
<h3>Introducing MoonMon</h3>

<div style="text-align: center;"><i>MoonMon is an endpoint monitoring and policy enforcement tool for Microsoft Windows.</i></div>
<br>

<p>The vision behind MoonMon is to expose monitoring and policy enforcement capabilities as part of a free and open-source software.</p>

<p>The need I had was just that: free software I can use to monitor the Windows systems I'm using, both for security threats and general application behavior monitoring.</p>
<p>I also wanted a lot more control over my Windows systems. Linux had spoiled me quite a bit with the amount of control it permits. But also, using commercial endpoint security tools has left a lasting impression on me. 
</p>

<p>I'm also of the opinion that while threat intelligence products and detection/prevention content being commercial and proprietary makes sense, the actual capabilities to operationalize such content should be exposed to users freely.
If MoonMon matures enough, and enough people find it useful, my hope is that it can use public and crowdsourced threat intelligence to detect and/or prevent real-world threats someday. Not as a replacement for existing anti-virus or EDR tools, but to complement them, or to be used by users who can't afford them.
</p>
<br><br>
<h4>What can MoonMon do today?</h4>

<p>If you haven't already, check out "<a href="https://github.com/ag-michael/MoonMon#the-big-and-long-list-of-features-and-ideas" target="_blank">The big and long list of features and ideas!</a>" in the project's Readme.</p>
<p>Before talking about the logging and prevention capabilities, it's important to describe the configuration capabilities it offers.</p>
  <p>MoonMon takes a rule-centric approach. The user-space agent (Luna), responsible for installing and configuring MoonMon, processes configuration content defined in YAML configuration files.</p>
 <p>Global settings allow defining various install-time parameters as well as run-time settings, such as enabling or disabling the various callbacks and filters the driver uses. </p>
<p>Various "lists" contain event-source-specific rules where matches have a predefined effect, such as blocking, logging, or excluding (from logging) matching events.</p>
  
  <p>For example, it can be configured to block, but not log, only specific process-creation events for a specific process, such as a browser starting an unusual process, and nothing more. Global settings can disable all callbacks and filters except for the process creation callback, minimizing the impact on performance.
  </p><p>Or, it can be configured to log every supported event type, rotating logs as they fill up, with exceptions for the really noisy log-generating patterns. </p>
  <p>It can be used to lock down a system by permitting specific allowlisted patterns of process creation, file activity (creation, tampering, opening), registry activity, process access attempts, and more. </p>

<p>The repository contains a <a href="https://github.com/ag-michael/MoonMon/tree/master/samples" target="_blank">samples</a> directory that contains log samples as well as example configurations, which I plan to expand over time. The config directory by default also ships with a '<a href="https://github.com/ag-michael/MoonMon/blob/master/config/tests.yaml" target="_blank">tests.yaml</a>' configuration file, which I'm using to test and validate some basic assumptions I have about the functionality of various features, but it can also come in handy as an example configuration.</p>
<br><br>
<h3>MoonMon's Future</h3>

<p>When I started working on this project, I knew it was going to be a significant undertaking—and it was—but a lot of the heavy-lifting and architectural decision-making now seems to be more or less complete. </p>
  <p>My focus so far has been to write a somewhat stable driver and a stable user-space agent.</p>
  <p>From the driver side of things, I've avoided using complex tricks or logic that makes it more difficult to read the code, or more difficult to refactor.</p>
  <p>Most of the core driver features are implemented; now my focus is on hardening them while carefully making changes that would improve performance or simply reduce the amount of code. I want to do all this while expanding on the portfolio of tests I need to help reduce the potential of inadvertent bug-introduction.</p>
  <p>At some point, I want to feature-freeze the driver and only touch it for security fixes, hardening, or supporting newer versions of Windows. </p>

  <p>In the near term, I plan on working towards implementing some kernel-mode features such as KAPC injection rules, dynamic configuration reloading, and a more complete tamper-resistance capability. Aside from those, there are still some significant kernel-mode features, such as ETW telemetry that I won't get to for a while, as well as things like Early-Launch Anti-Malware (ELAM) certification and code-signing MoonMon. Much of that depends on other people finding the project useful, if MoonMon becomes production-ready, and if I gain strong confidence in its security posture, as well as finances and Microsoft's good graces.</p>
  <p>I have many other features I haven't implemented yet that are best-implemented by user-space code. The user-space agent (Luna) is where I'm expecting the most changes and feature additions to happen. 
  </p><p>Some interesting user-space features I've planned include YARA scanning (including using YARA rules as part of AMSI scanning), enrichments such as PE headers, file magic, Mark-of-the-Web, and more.</p>
    <p>I also plan on experimenting with user-space-driven prevention capabilities, such as a YARA match resulting in process termination, or PE header details resulting in adding file-access restrictions.</p>
<p>There are two ideas I'm looking forward to researching and implementing the most. Remote binary logging, which I'm betting will dramatically improve performance by freeing up disk I/O resources as well as freeing the agent from processing logs before shipping centrally. And NTFS ADS tagging—which sounds simple, just add data under NTFS alternative data streams, but could be powerful because those "tags," I'm hoping at least, could be used as part of more complex rules. For example, "If Firefox created the file, the file can't be executed or opened by any other process," or "If a file was downloaded from a specific website, it can't be moved outside of a specific path regex."</p>
    <p>Needless to say, I have many ideas and features I want to experiment with, but my plan is to work on MoonMon incrementally and at a slow-and-steady pace, since after all, I am currently working on it solo and my free time is limited.</p>
      <p>I have been having lots of fun working on MoonMon, and now that the scaffolding is more or less there, I'm hoping incremental and atomic changes over time will result in something useful, not just to myself but to others as well.
    </p>
    <br><br>
    <h4>Benchmarks, Fuzzing and Contributions</h4>

    <p>Initially, I didn't really plan on making MoonMon public. My main goal was to write something similar to the endpoint tools I've grown to like, and then learn how to best evade, bypass, or find security vulnerabilities in it.</p>
      <p>I have an unpublished project I've been working on to measure stress-test-driven benchmarks. But more importantly, I plan on reusing the code for stress testing to generate fuzzing harnesses for MoonMon. I've been learning how to do all of that properly, and I'm hoping to translate all of that work into vulnerability research skills.
    </p>
    <p>With all of that—a decent backlog of exploit-development labs, books, and papers to read up on, and real life getting in the way—I could use a lot of help with this project.</p>
      <p>So if you find it useful or interesting at all, star the project, send me a message on Bluesky, start an issue or a discussion on GitHub, or just share the word about MoonMon with others. 
    </p>
    <p>I could use lots of help with fixing bugs or adding features (PRs are most welcome!). But the help I need the most right now is with code review. This is my first time publishing a public project like this, and while I've written C for a long time (and Go for even less), it is very easy to make mistakes or come up with a bad architecture.</p>
      <p>On top of that, writing driver code is a precarious effort. That is all to say that MoonMon needs lots of code review and improvements so that someday there will be enough confidence in it to consider paying for code-signing certificates and publishing a driver that loads without test-signing mode enabled.</p>
  <p>I hope you'll find MoonMon interesting and potentially useful. Constructive criticism, feedback, bug reports, feature requests, and pull requests are all welcome.</p>
  <p>I plan on creating similar blog posts as part of this series to expand more on MoonMon's internals, architecture, and all the quirks and tricks I've picked up while writing MoonMon and debugging it. Stay tuned!</p>
</div> 

<!-- Footer -->
    <br><br>
<div style="background-color:#1a1b1c;margin-left:20%;display:flex;justify-content: space-evenly;align-items: center;position:sticky;opacity:1;z-index: 3;">
<div style="text-align: left;margin-right:20%;"><a href="https://github.com/ag-michael">My Github</a></div>
<div style="text-align: center;margin-right:20%;">Email:infosec-michael[at]pm . me</a></div>
<div style="text-align: right;margin-right:20%;"><a href="https://bsky.app/profile/infosec-michael.bsky.social">@infosec-michael</a></div>
</div>

</body></html>
